---
title: "spatial_modeling_demo"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{spatial_modeling_demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(SpatialBasis)
library(DownscalingPaper)
```

```{r}
# Spatial Downscaling Example: SAR + Covariate with Piecewise Constant Basis

# Load packa gesGI
library(sf)
library(Matrix)
#library(downscaling)  # replace with your actual package name

response <- "synthetic_albedo"

intersects_soundings <- sf::st_intersects(target_grid,soundings)
intersects_soundings <- lapply(intersects_soundings,function(x){length(x) > 0})
intersects_soundings <- unlist(intersects_soundings)

how_many_intersects <- sf::st_intersects(target_grid,soundings)
how_many_intersects <- lapply(how_many_intersects,function(x){length(x)})
how_many_intersects <- unlist(how_many_intersects)

# Step 1: Construct Basis and Priors

# -- Response field: SAR prior on a geometry basis (from soundings)
basis_resp <- make_geometry_basis(target_grid)
prior_resp <- make_sar_prior(basis_resp,tau = 0.06, rho = 1)

response_field <- make_spatial_field(
  basis = basis_resp,
  prior = prior_resp,
  integration_rule = integration_rule_area_overlap(),
  label = response
)

# Prepare integrated design matrices
prepared_list <- prepare_spatial_data(
  response_field,
  observation_data = DownscalingPaper::soundings_paper,
  response = response,
  parallel = TRUE,
  n_workers = future::availableCores(),
  compute_cholesky = TRUE
)



# Fit the model
(system.time(fit <- fit_spatial_field(
  prepared_list, return_variance = TRUE
)))

# Step 3: Visualize Fitted Values

soundings_paper <- DownscalingPaper::soundings_paper
soundings_paper$fitted <- fit$fitted

plot(soundings_paper[response], main = "Observed")
plot(soundings_paper["fitted"], main = "Fitted (Posterior Mean)")

# Step 4: Predict on Grid

# Get coordinates from the target grid
grid_coords <- sf::st_coordinates(sf::st_centroid(target_grid))

# Predict from fitted model
system.time(pred <- predict(fit, newdata = grid_coords, return_variance = TRUE, diagonal_only = FALSE))
target_grid$predicted <- pred$preds
target_grid$var <- Matrix::diag(pred$posterior_variance)

# Visualize predictions
plot(target_grid["var"], main = "Predicted variance on Grid")

lb <- target_grid$predicted-1.96*sqrt(target_grid$var)
ub <- target_grid$predicted+1.96*sqrt(target_grid$var)

mean(target_grid$mean_value > lb & target_grid$mean_value < ub)

target_grid$outside <- target_grid$mean_value > lb & target_grid$mean_value < ub

plot(target_grid["outside"], main = "Errors from approximate coverage interval")

```



```{r}
# Spatial Downscaling Example: SAR + Covariate with Piecewise Constant Basis

# Load packagesGI
library(sf)
library(Matrix)
#library(downscaling)  # replace with your actual package name

response <- "synthetic_albedo"

alph = 1

W <- compute_W_matrix(target_grid,grid_shape = "other")

target_grid$proportion_6 = ifelse(is.na(target_grid$proportion_6),0,target_grid$proportion_6)

landcover_weights <- outer(target_grid$proportion_6,target_grid$proportion_6,function(x,y){1-alph*abs(x-y)})

W_new <- W*landcover_weights# (1-alph)*W+alpha*W*landcover_weights ?? =W $W-alpha 

W_new <- W#Matrix::diag(1/rowSums(W_new)) %*% W_new

# Step 1: Construct Basis and Priors

# -- Response field: SAR prior on a geometry basis (from soundings)
basis_resp <- make_geometry_basis(target_grid)
prior_resp <- make_sar_prior(basis_resp, tau = 0.06, rho = 0.99,W = W_new)

basis_cov <- make_piecewise_constant_basis(SpatialBasis::boston_watercover,values = c(1,0))
basis_prior <- make_flat_prior(basis_cov)

basis_intercept <- make_constant_basis()
prior_intercept <- make_flat_prior(basis_intercept)

response_field <- make_spatial_field(
  basis = basis_resp,
  prior = prior_resp,
  label = response
)

covariate_field <- make_spatial_field(basis = basis_cov, prior = basis_prior, integration_rule = integration_rule_area_overlap(), label = "water")

intercept_field <- make_spatial_field(basis = basis_intercept, prior = prior_intercept, integration_rule = integration_rule_qmc_average(generate_qmc_unit_square(1)),label = "intercept")

#prepared_covariates <- prepare_spatial_data(covariate_field,DownscalingPaper::soundings_paper,response,parallel = TRUE)

# Prepare integrated design matrices
prepared_list <- prepare_spatial_field_list(
  list(resid = response_field,cov = covariate_field,intercept = intercept_field),
  observation_data = DownscalingPaper::soundings_paper,
  response = response,
  parallel = TRUE,
  n_workers = future::availableCores(),
  compute_cholesky = TRUE
)

stacked <- stack_spatial_design_matrices(prepared_list)


# Fit the model
(system.time(fit2 <- fit_stacked_spatial_field(
  stacked, orthogonalize = TRUE, return_variance = FALSE
)))

# Step 3: Visualize Fitted Values

soundings_paper <- DownscalingPaper::soundings_paper
soundings_paper$fitted <- fit$fitted

plot(soundings_paper[response], main = "Observed")
plot(soundings_paper["fitted"], main = "Fitted (Posterior Mean)")

# Step 4: Predict on Grid

# Get coordinates from the target grid
grid_coords <- sf::st_coordinates(sf::st_centroid(target_grid))

# Predict from fitted model
system.time(pred <- predict(fit2, newdata = target_grid, return_variance = TRUE, diagonal_only = TRUE))
target_grid$predicted <- pred$preds
target_grid$var <- pred$posterior_variance

l <- target_grid$mean_value > target_grid$predicted-1.96*sqrt(target_grid$var)
u <- target_grid$mean_value < target_grid$predicted+1.96*sqrt(target_grid$var)

mean(l[intersects_soundings] & u[intersects_soundings])

# Visualize predictions
plot(target_grid["var"], main = "Predicted variance on Grid")

lb <- target_grid$predicted-0.95*sqrt(target_grid$var)
ub <- target_grid$predicted+0.95*sqrt(target_grid$var)

mean(target_grid$mean_value > lb & target_grid$mean_value < ub)

target_grid$outside <- mean(target_grid$mean_value > lb & target_grid$mean_value < ub)

plot(target_grid["outside"], main = "Errors from approximate coverage interval")
```


```{r}
# Spatial Downscaling Example: SAR + Covariate with Piecewise Constant Basis

# Load packages
library(sf)
library(Matrix)
#library(downscaling)  # replace with your actual package name

# Step 1: Construct Basis and Priors

# -- Response field: SAR prior on a geometry basis (from soundings)
basis_resp <- make_geometry_basis(target_grid)
prior_resp <- make_sar_prior(basis_resp, tau = 30)

response_field <- make_spatial_field(
  basis = basis_resp,
  prior = prior_resp,
  label = "SIF_757nm"
)

# -- Covariate field: piecewise constant on the grid (mean_value)
basis_cov <- make_piecewise_constant_basis(target_grid, values = target_grid$mean_value)
prior_cov <- make_ridge_prior(basis_cov)  # treated as fixed effect

covariate_field <- make_spatial_field(
  basis = basis_cov,
  prior = prior_cov,
  label = "mean_value"
)

# Step 2: Prepare and Fit the Model
# Combine both fields into a list
field_list <- list(response_field, covariate_field)

# Prepare integrated design matrices
prepared_list <- prepare_spatial_field_list(
  field_list,
  observation_data = soundings,
  response = "SIF_757nm",
  parallel = TRUE,
  n_workers = future::availableCores()
)

# Stack matrices and priors
stacked <- stack_spatial_design_matrices(prepared_list)

# Fit the model
fit <- fit_stacked_spatial_field(
  stacked
)

# Step 3: Visualize Fitted Values

soundings$fitted_SIF <- fit$fitted

plot(soundings["SIF_757nm"], main = "Observed SIF")
plot(soundings["fitted_SIF"], main = "Fitted SIF (Posterior Mean)")

# Step 4: Predict on Grid

# Get coordinates from the target grid
grid_coords <- sf::st_coordinates(sf::st_centroid(target_grid))

# Predict from fitted model
target_grid$predicted_SIF <- predict(fit, newdata = grid_coords)

system.time(pred <- predict(fit, newdata = grid_coords, return_variance = TRUE, diagonal_only = TRUE))

target_grid$var <- diag(attr(pred,"posterior_variance"))

# Visualize predictions
plot(target_grid["var"], main = "Predicted SIF on Grid")

```


```{r}
# Spatial Downscaling Example: SAR + Covariate with Piecewise Constant Basis

# Load packages
library(sf)
library(Matrix)
library(downscaling)  # replace with your actual package name

# Step 1: Construct Basis and Priors

# -- Response field: SAR prior on a geometry basis (from soundings)
basis_resp <- make_geometry_basis(target_grid)
prior_resp <- make_sar_prior(basis_resp, tau = 30)

response_field <- make_spatial_field(
  basis = basis_resp,
  prior = prior_resp,
  label = "SIF_757nm"
)

# -- Covariate field: piecewise constant on the grid (mean_value)
basis_cov <- make_piecewise_constant_basis(target_grid, values = target_grid$mean_value)
prior_cov <- make_ridge_prior(basis_cov, tau = 1)  # treated as fixed effect

covariate_field <- make_spatial_field(
  basis = basis_cov,
  prior = prior_cov,
  label = "mean_value"
)

# Step 2: Prepare and Fit the Model

# Combine both fields into a list
field_list <- list(response_field)

# Prepare integrated design matrices
prepared_list <- prepare_spatial_field_list(
  field_list,
  observation_data = soundings,
  response = "SIF_757nm",
  parallel = TRUE,
  n_workers = future::availableCores()
)

# Stack matrices and priors
stacked <- stack_spatial_design_matrices(prepared_list)

# Fit the model
fit2 <- fit_stacked_spatial_field(
  stacked
)

# Step 3: Visualize Fitted Values

soundings$fitted_SIF <- fit2$fitted

plot(soundings["SIF_757nm"], main = "Observed SIF")
plot(soundings["fitted_SIF"], main = "Fitted SIF (Posterior Mean)")

# Step 4: Predict on Grid

# Get coordinates from the target grid
grid_coords <- sf::st_coordinates(sf::st_centroid(target_grid))

# Predict from fitted model
target_grid$predicted_SIF <- predict(fit2, newdata = grid_coords)

# Visualize predictions
plot(target_grid["predicted_SIF"], main = "Predicted SIF on Grid")

```

```{r}
# Spatial Downscaling Example: SAR + Covariate with Piecewise Constant Basis

# Load packages
library(sf)
library(Matrix)
library(downscaling)  # replace with your actual package name

# Step 1: Construct Basis and Priors

# -- Response field: SAR prior on a geometry basis (from soundings)
basis_resp <- make_geometry_basis(target_grid)
prior_resp <- make_sar_prior(basis_resp, tau = 30)

response_field <- make_spatial_field(
  basis = basis_resp,
  prior = prior_resp,
  label = "SIF_757nm"
)

# -- Covariate field: piecewise constant on the grid (mean_value)
basis_cov <- make_geometry_basis(boston_watercover)
prior_cov <- make_flat_prior(basis_cov)  # treated as fixed effect

covariate_field <- make_spatial_field(
  basis = basis_cov,
  prior = prior_cov,
  label = "water"
)

# Step 2: Prepare and Fit the Model

# Combine both fields into a list
field_list <- list(response_field,covariate_field)

# Prepare integrated design matrices
prepared_list <- prepare_spatial_field_list(
  field_list,
  observation_data = DownscalingPaper::soundings_paper,
  response = "SIF_757nm",
  parallel = TRUE,
  n_workers = future::availableCores()
)

# Stack matrices and priors
stacked <- stack_spatial_design_matrices(prepared_list)

# Fit the model
fit3 <- fit_stacked_spatial_field(
  stacked, orthogonalize = TRUE
)

# Step 3: Visualize Fitted Values

soundings$fitted_SIF <- fit3$fitted

plot(soundings["SIF_757nm"], main = "Observed SIF")
plot(soundings["fitted_SIF"], main = "Fitted SIF (Posterior Mean)")

# Step 4: Predict on Grid

# Get coordinates from the target grid
grid_coords <- sf::st_coordinates(sf::st_centroid(target_grid))

# Predict from fitted model
target_grid$predicted_SIF <- predict(fit3, newdata = grid_coords)

# Visualize predictions
plot(target_grid["predicted_SIF"], main = "Predicted SIF on Grid")

```
```{r}
# Spatial Downscaling Example: SAR + Covariate with Piecewise Constant Basis

# Load packages
library(sf)
library(Matrix)
library(downscaling)  # replace with your actual package name

# Step 1: Construct Basis and Priors

# -- Response field: SAR prior on a geometry basis (from soundings)
basis_resp <- make_geometry_basis(target_grid)
prior_resp <- make_sar_prior(basis_resp, tau = 8)

response_field <- make_spatial_field(
  basis = basis_resp,
  prior = prior_resp,
  label = "synthetic_albedo"
)

# -- Covariate field: piecewise constant on the grid (mean_value)
basis_cov <- make_geometry_basis(boston_watercover)
prior_cov <- make_flat_prior(basis_cov) # treated as fixed effect

covariate_field <- make_spatial_field(
  basis = basis_cov,
  prior = prior_cov,
  label = "water"
)

# Step 2: Prepare and Fit the Model

# Combine both fields into a list
field_list <- list(response_field,covariate_field)

# Prepare integrated design matrices
prepared_list <- prepare_spatial_field_list(
  field_list,
  observation_data = DownscalingPaper::soundings_paper,
  response = "synthetic_albedo",
  parallel = TRUE,
  n_workers = future::availableCores()
)

# Stack matrices and priors
stacked <- stack_spatial_design_matrices(prepared_list)

# Fit the model
fit4 <- fit_stacked_spatial_field(
  stacked,orthogonal = TRUE
)

# Step 3: Visualize Fitted Values

soundings$fitted_synthetic_albedo <- fit4$fitted

plot(DownscalingPaper::soundings_paper["synthetic_albedo"], main = "Observed synthetic_albedo")
plot(soundings["fitted_synthetic_albedo"], main = "Fitted synthetic_albedo (Posterior Mean)")

# Step 4: Predict on Grid

# Get coordinates from the target grid
grid_coords <- sf::st_coordinates(sf::st_centroid(target_grid))

# Predict from fitted model
target_grid$predicted_synthetic_albedo <- predict(fit4, newdata = grid_coords)

# Visualize predictions
plot(target_grid["predicted_synthetic_albedo"], main = "Predicted synthetic_albedo on Grid")

ggplot()+geom_point(data = target_grid,aes(x = predicted_synthetic_albedo, y = mean_value, color = proportion_6))

```


## JUST WATER?

```{r}
# Spatial Downscaling Example: SAR + Covariate with Piecewise Constant Basis

# Load packages
library(sf)
library(Matrix)
library(downscaling)  # replace with your actual package name

# Step 1: Construct Basis and Priors

# -- Response field: SAR prior on a geometry basis (from soundings)
basis_resp <- make_geometry_basis(boston_watercover)
prior_resp <- make_flat_prior(basis_resp)

response_field <- make_spatial_field(
  basis = basis_resp,
  prior = prior_resp,
  label = "SIF_757nm"
)


# Step 2: Prepare and Fit the Model

# Combine both fields into a list
field_list <- list(response_field)

# Prepare integrated design matrices
prepared_list <- prepare_spatial_field_list(
  field_list,
  observation_data = soundings,
  response = "SIF_757nm",
  parallel = TRUE,
  n_workers = future::availableCores()
)

# Stack matrices and priors
stacked <- stack_spatial_design_matrices(prepared_list)

# Fit the model
fit3 <- fit_stacked_spatial_field(
  stacked
)

# Step 3: Visualize Fitted Values

soundings$fitted_SIF <- fit3$fitted

plot(soundings["SIF_757nm"], main = "Observed SIF")
plot(soundings["fitted_SIF"], main = "Fitted SIF (Posterior Mean)")

# Step 4: Predict on Grid

# Get coordinates from the target grid
grid_coords <- sf::st_coordinates(sf::st_centroid(target_grid))

# Predict from fitted model
target_grid$predicted_SIF <- predict(fit3, newdata = grid_coords)

# Visualize predictions
plot(target_grid["predicted_SIF"], main = "Predicted SIF on Grid")
```




